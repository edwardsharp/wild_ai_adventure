{"version":3,"file":"websocket-client-mANlKmgB.js","sources":["../src/lib/websocket-types.ts","../src/lib/websocket-client.ts"],"sourcesContent":["/**\n * WebSocket message types and Zod schemas for type-safe communication\n *\n * These types mirror the Rust serde types on the server side to ensure\n * consistent message format between client and server.\n */\n\nimport { z } from \"zod\";\n\n// Base schemas\nconst UuidSchema = z.string().uuid();\nconst DateTimeSchema = z.string().datetime();\n\n/**\n * Media blob data structure matching the server-side MediaBlob\n */\nexport const MediaBlobSchema = z.object({\n  id: UuidSchema,\n  data: z.array(z.number()).optional(), // Vec<u8> as number array, often omitted\n  sha256: z.string(),\n  size: z.number().int().optional(),\n  mime: z.string().optional(),\n  source_client_id: z.string().optional(),\n  local_path: z.string().optional(),\n  metadata: z.record(z.any()).default({}), // JSONB as Record<string, any>\n  created_at: DateTimeSchema,\n  updated_at: DateTimeSchema,\n});\n\nexport type MediaBlob = z.infer<typeof MediaBlobSchema>;\n\n/**\n * Messages sent from client to server\n */\nexport const WebSocketMessageSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"Ping\"),\n  }),\n  z.object({\n    type: z.literal(\"GetMediaBlobs\"),\n    data: z\n      .object({\n        limit: z.number().int().positive().optional(),\n        offset: z.number().int().min(0).optional(),\n      })\n      .optional(),\n  }),\n  z.object({\n    type: z.literal(\"UploadMediaBlob\"),\n    data: z.object({\n      blob: MediaBlobSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal(\"GetMediaBlob\"),\n    data: z.object({\n      id: UuidSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal(\"GetMediaBlobData\"),\n    data: z.object({\n      id: UuidSchema,\n    }),\n  }),\n]);\n\nexport type WebSocketMessage = z.infer<typeof WebSocketMessageSchema>;\n\n/**\n * Messages sent from server to client\n */\nexport const WebSocketResponseSchema = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"Welcome\"),\n    data: z.object({\n      message: z.string(),\n      user_id: UuidSchema.optional(),\n      connection_id: z.string(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"Pong\"),\n  }),\n  z.object({\n    type: z.literal(\"MediaBlobs\"),\n    data: z.object({\n      blobs: z.array(MediaBlobSchema),\n      total_count: z.number().int().min(0),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"MediaBlob\"),\n    data: z.object({\n      blob: MediaBlobSchema,\n    }),\n  }),\n  z.object({\n    type: z.literal(\"MediaBlobData\"),\n    data: z.object({\n      id: UuidSchema,\n      data: z.array(z.number()),\n      mime: z.string().optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"Error\"),\n    data: z.object({\n      message: z.string(),\n      code: z.string().optional(),\n    }),\n  }),\n  z.object({\n    type: z.literal(\"ConnectionStatus\"),\n    data: z.object({\n      connected: z.boolean(),\n      user_count: z.number().int().min(0),\n    }),\n  }),\n]);\n\nexport type WebSocketResponse = z.infer<typeof WebSocketResponseSchema>;\n\n/**\n * Connection status for presence indication\n */\nexport enum ConnectionStatus {\n  Disconnected = \"disconnected\", // Red light\n  Connecting = \"connecting\", // Yellow light\n  Connected = \"connected\", // Green light\n  Error = \"error\", // Red light with error\n}\n\n/**\n * Helper functions for message creation and validation\n */\nexport const createMessage = {\n  ping: (): WebSocketMessage => ({ type: \"Ping\" }),\n\n  getMediaBlobs: (limit?: number, offset?: number): WebSocketMessage => ({\n    type: \"GetMediaBlobs\",\n    data: { limit, offset },\n  }),\n\n  getMediaBlob: (id: string): WebSocketMessage => ({\n    type: \"GetMediaBlob\",\n    data: { id },\n  }),\n\n  getMediaBlobData: (id: string): WebSocketMessage => ({\n    type: \"GetMediaBlobData\",\n    data: { id },\n  }),\n\n  uploadMediaBlob: (blob: MediaBlob): WebSocketMessage => ({\n    type: \"UploadMediaBlob\",\n    data: { blob },\n  }),\n};\n\n/**\n * Utility functions for message parsing and validation\n */\nexport const parseWebSocketMessage = (data: unknown): WebSocketMessage => {\n  return WebSocketMessageSchema.parse(data);\n};\n\nexport const parseWebSocketResponse = (data: unknown): WebSocketResponse => {\n  return WebSocketResponseSchema.parse(data);\n};\n\n/**\n * Safe message parsing that returns error instead of throwing\n */\nexport const safeParseWebSocketResponse = (\n  data: unknown\n):\n  | { success: true; data: WebSocketResponse }\n  | { success: false; error: z.ZodError } => {\n  const result = WebSocketResponseSchema.safeParse(data);\n  return result;\n};\n\n/**\n * Type guards for response types\n */\nexport const isWelcomeMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"Welcome\" }> => {\n  return response.type === \"Welcome\";\n};\n\nexport const isMediaBlobsMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"MediaBlobs\" }> => {\n  return response.type === \"MediaBlobs\";\n};\n\nexport const isErrorMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"Error\" }> => {\n  return response.type === \"Error\";\n};\n\nexport const isConnectionStatusMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"ConnectionStatus\" }> => {\n  return response.type === \"ConnectionStatus\";\n};\n\nexport const isMediaBlobMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"MediaBlob\" }> => {\n  return response.type === \"MediaBlob\";\n};\n\nexport const isMediaBlobDataMessage = (\n  response: WebSocketResponse\n): response is Extract<WebSocketResponse, { type: \"MediaBlobData\" }> => {\n  return response.type === \"MediaBlobData\";\n};\n\n/**\n * Validates and parses incoming WebSocket message with detailed error info\n */\nexport const validateIncomingMessage = (\n  rawData: string\n):\n  | { success: true; data: WebSocketResponse }\n  | { success: false; error: string; details?: unknown } => {\n  try {\n    const json = JSON.parse(rawData);\n    const result = WebSocketResponseSchema.safeParse(json);\n\n    if (result.success) {\n      return { success: true, data: result.data };\n    } else {\n      return {\n        success: false,\n        error: \"Message validation failed\",\n        details: result.error.flatten(),\n      };\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: \"Invalid JSON\",\n      details: error instanceof Error ? error.message : String(error),\n    };\n  }\n};\n\n/**\n * Validates outgoing WebSocket message before sending\n */\nexport const validateOutgoingMessage = (\n  message: unknown\n):\n  | { success: true; data: WebSocketMessage }\n  | { success: false; error: string; details?: unknown } => {\n  const result = WebSocketMessageSchema.safeParse(message);\n\n  if (result.success) {\n    return { success: true, data: result.data };\n  } else {\n    return {\n      success: false,\n      error: \"Message validation failed\",\n      details: result.error.flatten(),\n    };\n  }\n};\n","/**\n * WebSocket client for real-time communication with the server\n *\n * Provides type-safe WebSocket communication with automatic reconnection,\n * message parsing, and connection status tracking.\n */\n\nimport {\n  WebSocketMessage,\n  ConnectionStatus,\n  safeParseWebSocketResponse,\n  createMessage,\n  MediaBlob,\n} from \"./websocket-types.js\";\n\n// Re-export types for convenience\nexport { ConnectionStatus } from \"./websocket-types.js\";\n\nexport interface WebSocketClientConfig {\n  /** WebSocket URL (e.g., 'ws://localhost:3000/ws') */\n  url: string;\n  /** Automatic reconnection enabled */\n  autoReconnect?: boolean;\n  /** Reconnection delay in milliseconds */\n  reconnectDelay?: number;\n  /** Maximum reconnection attempts (0 = infinite) */\n  maxReconnectAttempts?: number;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\nexport interface WebSocketClientEvents {\n  /** Connection status changed */\n  statusChange: (status: ConnectionStatus) => void;\n  /** Received welcome message */\n  welcome: (data: {\n    message: string;\n    user_id?: string;\n    connection_id: string;\n  }) => void;\n  /** Received media blobs */\n  mediaBlobs: (data: { blobs: MediaBlob[]; total_count: number }) => void;\n  /** Received single media blob */\n  mediaBlob: (data: { blob: MediaBlob }) => void;\n  /** Received error message */\n  error: (data: { message: string; code?: string }) => void;\n  /** Connection status update from server */\n  connectionStatus: (data: { connected: boolean; user_count: number }) => void;\n  /** Raw message received (for debugging) */\n  rawMessage: (message: string) => void;\n  /** Message parse error */\n  parseError: (error: Error, rawMessage: string) => void;\n}\n\nexport class WebSocketClient {\n  private socket: WebSocket | null = null;\n  private config: Required<WebSocketClientConfig>;\n  private status: ConnectionStatus = ConnectionStatus.Disconnected;\n  private listeners: Partial<WebSocketClientEvents> = {};\n  private reconnectAttempts = 0;\n  private reconnectTimer: number | null = null;\n  private pingInterval: number | null = null;\n\n  constructor(config: WebSocketClientConfig) {\n    this.config = {\n      autoReconnect: true,\n      reconnectDelay: 3000,\n      maxReconnectAttempts: 0,\n      debug: false,\n      ...config,\n    };\n  }\n\n  /**\n   * Add event listener\n   */\n  on<K extends keyof WebSocketClientEvents>(\n    event: K,\n    listener: WebSocketClientEvents[K]\n  ): void {\n    this.listeners[event] = listener;\n  }\n\n  /**\n   * Remove event listener\n   */\n  off<K extends keyof WebSocketClientEvents>(event: K): void {\n    delete this.listeners[event];\n  }\n\n  /**\n   * Get current connection status\n   */\n  getStatus(): ConnectionStatus {\n    return this.status;\n  }\n\n  /**\n   * Connect to WebSocket server\n   */\n  connect(): void {\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.log(\"Already connected\");\n      return;\n    }\n\n    this.setStatus(ConnectionStatus.Connecting);\n    this.log(`Connecting to ${this.config.url}`);\n\n    try {\n      this.socket = new WebSocket(this.config.url);\n      this.setupSocketListeners();\n    } catch (error) {\n      this.log(\"Connection error:\", error);\n      this.setStatus(ConnectionStatus.Error);\n      this.scheduleReconnect();\n    }\n  }\n\n  /**\n   * Disconnect from WebSocket server\n   */\n  disconnect(): void {\n    this.log(\"Disconnecting...\");\n    this.clearReconnectTimer();\n    this.clearPingInterval();\n\n    if (this.socket) {\n      this.socket.close(1000, \"Client disconnect\");\n      this.socket = null;\n    }\n\n    this.setStatus(ConnectionStatus.Disconnected);\n  }\n\n  /**\n   * Send a message to the server\n   */\n  send(message: WebSocketMessage): boolean {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      this.log(\"Cannot send message: not connected\");\n      return false;\n    }\n\n    try {\n      const json = JSON.stringify(message);\n      this.socket.send(json);\n      this.log(\"Sent message:\", message);\n      return true;\n    } catch (error) {\n      this.log(\"Send error:\", error);\n      return false;\n    }\n  }\n\n  /**\n   * Send ping message\n   */\n  ping(): boolean {\n    return this.send(createMessage.ping());\n  }\n\n  /**\n   * Request media blobs list\n   */\n  getMediaBlobs(limit?: number, offset?: number): boolean {\n    return this.send(createMessage.getMediaBlobs(limit, offset));\n  }\n\n  /**\n   * Request specific media blob\n   */\n  getMediaBlob(id: string): boolean {\n    return this.send(createMessage.getMediaBlob(id));\n  }\n\n  /**\n   * Upload media blob\n   */\n  uploadMediaBlob(blob: MediaBlob): boolean {\n    return this.send(createMessage.uploadMediaBlob(blob));\n  }\n\n  private setupSocketListeners(): void {\n    if (!this.socket) return;\n\n    this.socket.onopen = () => {\n      this.log(\"Connected\");\n      this.setStatus(ConnectionStatus.Connected);\n      this.reconnectAttempts = 0;\n      this.startPing();\n    };\n\n    this.socket.onclose = (event) => {\n      this.log(`Connection closed: ${event.code} ${event.reason}`);\n      this.clearPingInterval();\n      this.setStatus(ConnectionStatus.Disconnected);\n\n      if (this.config.autoReconnect && event.code !== 1000) {\n        this.scheduleReconnect();\n      }\n    };\n\n    this.socket.onerror = (error) => {\n      this.log(\"Socket error:\", error);\n      this.setStatus(ConnectionStatus.Error);\n    };\n\n    this.socket.onmessage = (event) => {\n      this.handleMessage(event.data);\n    };\n  }\n\n  private handleMessage(rawMessage: string): void {\n    this.log(\"Received raw message:\", rawMessage);\n    this.listeners.rawMessage?.(rawMessage);\n\n    try {\n      const data = JSON.parse(rawMessage);\n      const parseResult = safeParseWebSocketResponse(data);\n\n      if (!parseResult.success) {\n        const error = new Error(\n          `Message parse error: ${parseResult.error.message}`\n        );\n        this.log(\"Parse error:\", error);\n        this.listeners.parseError?.(error, rawMessage);\n        return;\n      }\n\n      const response = parseResult.data;\n      this.log(\"Parsed message:\", response);\n\n      // Dispatch to specific handlers\n      switch (response.type) {\n        case \"Welcome\":\n          this.listeners.welcome?.(response.data);\n          break;\n        case \"Pong\":\n          this.log(\"Received pong\");\n          break;\n        case \"MediaBlobs\":\n          this.listeners.mediaBlobs?.(response.data);\n          break;\n        case \"MediaBlob\":\n          this.listeners.mediaBlob?.(response.data);\n          break;\n        case \"Error\":\n          this.listeners.error?.(response.data);\n          break;\n        case \"ConnectionStatus\":\n          this.listeners.connectionStatus?.(response.data);\n          break;\n        default:\n          this.log(\"Unknown message type:\", response);\n      }\n    } catch (error) {\n      const parseError = new Error(`JSON parse error: ${error}`);\n      this.log(\"JSON parse error:\", parseError);\n      this.listeners.parseError?.(parseError, rawMessage);\n    }\n  }\n\n  private setStatus(status: ConnectionStatus): void {\n    if (this.status !== status) {\n      this.status = status;\n      this.log(`Status changed to: ${status}`);\n      this.listeners.statusChange?.(status);\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (!this.config.autoReconnect) return;\n\n    if (\n      this.config.maxReconnectAttempts > 0 &&\n      this.reconnectAttempts >= this.config.maxReconnectAttempts\n    ) {\n      this.log(\"Max reconnection attempts reached\");\n      return;\n    }\n\n    this.clearReconnectTimer();\n    this.reconnectAttempts++;\n\n    this.log(\n      `Scheduling reconnect attempt ${this.reconnectAttempts} in ${this.config.reconnectDelay}ms`\n    );\n\n    this.reconnectTimer = window.setTimeout(() => {\n      this.connect();\n    }, this.config.reconnectDelay);\n  }\n\n  private clearReconnectTimer(): void {\n    if (this.reconnectTimer !== null) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n  }\n\n  private startPing(): void {\n    this.clearPingInterval();\n    // Send ping every 30 seconds to keep connection alive\n    this.pingInterval = window.setInterval(() => {\n      this.ping();\n    }, 30000);\n  }\n\n  private clearPingInterval(): void {\n    if (this.pingInterval !== null) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  private log(...args: unknown[]): void {\n    if (this.config.debug) {\n      console.log(\"[WebSocketClient]\", ...args);\n    }\n  }\n}\n"],"names":["UuidSchema","z.string","DateTimeSchema","MediaBlobSchema","z.object","z.array","z.number","z.record","z.any","z.discriminatedUnion","z.literal","WebSocketResponseSchema","z.boolean","ConnectionStatus","createMessage","limit","offset","id","blob","safeParseWebSocketResponse","data","WebSocketClient","config","event","listener","error","message","json","rawMessage","parseResult","response","parseError","status","args"],"mappings":"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"}